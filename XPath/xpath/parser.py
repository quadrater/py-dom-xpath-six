from __future__ import print_function
import xpath.expr as X
from yapps.runtime import Parser, Scanner, wrap_error_reporter


# Begin -- grammar generated by Yapps
import sys, re
from yapps import runtime

class XPathScanner(runtime.Scanner):
    patterns = [
        ("r'\\:'", re.compile('\\:')),
        ("r'node\\s*\\('", re.compile('node\\s*\\(')),
        ("r'text\\s*\\('", re.compile('text\\s*\\(')),
        ("r'comment\\s*\\('", re.compile('comment\\s*\\(')),
        ("r'processing-instruction\\s*\\('", re.compile('processing-instruction\\s*\\(')),
        ("r'\\,'", re.compile('\\,')),
        ("r'\\.'", re.compile('\\.')),
        ("r'\\$'", re.compile('\\$')),
        ("r'\\)'", re.compile('\\)')),
        ("r'\\('", re.compile('\\(')),
        ("r'\\]'", re.compile('\\]')),
        ("r'\\['", re.compile('\\[')),
        ("r'\\*'", re.compile('\\*')),
        ("r':'", re.compile(':')),
        ("r'\\.\\.'", re.compile('\\.\\.')),
        ("r'@'", re.compile('@')),
        ("r'::'", re.compile('::')),
        ("r'\\/\\/'", re.compile('\\/\\/')),
        ("r'\\/'", re.compile('\\/')),
        ("r'\\-'", re.compile('\\-')),
        ("'\\|'", re.compile('\\|')),
        ("r'and'", re.compile('and')),
        ("r'or'", re.compile('or')),
        ('\\s+', re.compile('\\s+')),
        ('END', re.compile('$')),
        ('FORWARD_AXIS_NAME', re.compile('child|descendant-or-self|attribute|self|descendant|following-sibling|following|namespace')),
        ('REVERSE_AXIS_NAME', re.compile('parent|preceding-sibling|preceding|ancestor-or-self|ancestor')),
        ('NCNAME', re.compile('[a-zA-Z_][a-zA-Z0-9_\\-\\.\\w]*(?!\\()')),
        ('FUNCNAME', re.compile('[a-zA-Z_][a-zA-Z0-9_\\-\\.\\w]*')),
        ('DQUOTE', re.compile('\\"(?:[^\\"])*\\"')),
        ('SQUOTE', re.compile("\\'(?:[^\\'])*\\'")),
        ('NUMBER', re.compile('((\\.[0-9]+)|([0-9]+(\\.[0-9]*)?))([eE][\\+\\-]?[0-9]+)?')),
        ('EQ_COMP', re.compile('\\!?\\=')),
        ('REL_COMP', re.compile('[\\<\\>]\\=?')),
        ('ADD_COMP', re.compile('[\\+\\-]')),
        ('MUL_COMP', re.compile('\\*|div|mod')),
    ]
    def __init__(self, str,*args,**kw):
        runtime.Scanner.__init__(self,None,{'\\s+':None,},str,*args,**kw)

class XPath(runtime.Parser):
    Context = runtime.Context
    def XPath(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'XPath', [])
        Expr = self.Expr(_context)
        END = self._scan('END', context=_context)
        return Expr

    def Expr(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'Expr', [])
        OrExpr = self.OrExpr(_context)
        return OrExpr

    def OrExpr(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'OrExpr', [])
        AndExpr = self.AndExpr(_context)
        Expr = AndExpr
        while self._peek("r'or'", 'END', "r'\\]'", "r'\\)'", "r'\\,'", context=_context) == "r'or'":
            self._scan("r'or'", context=_context)
            AndExpr = self.AndExpr(_context)
            Expr = X.OrExpr('or', Expr, AndExpr)
        return Expr

    def AndExpr(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'AndExpr', [])
        EqualityExpr = self.EqualityExpr(_context)
        Expr = EqualityExpr
        while self._peek("r'and'", "r'or'", 'END', "r'\\]'", "r'\\)'", "r'\\,'", context=_context) == "r'and'":
            self._scan("r'and'", context=_context)
            EqualityExpr = self.EqualityExpr(_context)
            Expr = X.AndExpr('and', Expr, EqualityExpr)
        return Expr

    def EqualityExpr(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'EqualityExpr', [])
        RelationalExpr = self.RelationalExpr(_context)
        Expr = RelationalExpr
        while self._peek('EQ_COMP', "r'and'", "r'or'", 'END', "r'\\]'", "r'\\)'", "r'\\,'", context=_context) == 'EQ_COMP':
            EQ_COMP = self._scan('EQ_COMP', context=_context)
            RelationalExpr = self.RelationalExpr(_context)
            Expr = X.EqualityExpr(EQ_COMP, Expr, RelationalExpr)
        return Expr

    def RelationalExpr(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'RelationalExpr', [])
        AdditiveExpr = self.AdditiveExpr(_context)
        Expr = AdditiveExpr
        while self._peek('REL_COMP', 'EQ_COMP', "r'and'", "r'or'", 'END', "r'\\]'", "r'\\)'", "r'\\,'", context=_context) == 'REL_COMP':
            REL_COMP = self._scan('REL_COMP', context=_context)
            AdditiveExpr = self.AdditiveExpr(_context)
            Expr = X.EqualityExpr(REL_COMP, Expr, AdditiveExpr)
        return Expr

    def AdditiveExpr(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'AdditiveExpr', [])
        MultiplicativeExpr = self.MultiplicativeExpr(_context)
        Expr = MultiplicativeExpr
        while self._peek('ADD_COMP', 'REL_COMP', 'EQ_COMP', "r'and'", "r'or'", 'END', "r'\\]'", "r'\\)'", "r'\\,'", context=_context) == 'ADD_COMP':
            ADD_COMP = self._scan('ADD_COMP', context=_context)
            MultiplicativeExpr = self.MultiplicativeExpr(_context)
            Expr = X.ArithmeticalExpr(ADD_COMP, Expr, MultiplicativeExpr)
        return Expr

    def MultiplicativeExpr(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'MultiplicativeExpr', [])
        UnionExpr = self.UnionExpr(_context)
        Expr = UnionExpr
        while self._peek('MUL_COMP', 'ADD_COMP', 'REL_COMP', 'EQ_COMP', "r'and'", "r'or'", 'END', "r'\\]'", "r'\\)'", "r'\\,'", context=_context) == 'MUL_COMP':
            MUL_COMP = self._scan('MUL_COMP', context=_context)
            UnionExpr = self.UnionExpr(_context)
            Expr = X.ArithmeticalExpr(MUL_COMP, Expr, UnionExpr)
        return Expr

    def UnionExpr(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'UnionExpr', [])
        UnaryExpr = self.UnaryExpr(_context)
        Expr = UnaryExpr
        while self._peek("'\\|'", 'MUL_COMP', 'ADD_COMP', 'REL_COMP', 'EQ_COMP', "r'and'", "r'or'", 'END', "r'\\]'", "r'\\)'", "r'\\,'", context=_context) == "'\\|'":
            self._scan("'\\|'", context=_context)
            UnaryExpr = self.UnaryExpr(_context)
            Expr = X.UnionExpr('|', Expr, UnaryExpr)
        return Expr

    def UnaryExpr(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'UnaryExpr', [])
        _token = self._peek("r'\\-'", "r'\\/'", "r'\\/\\/'", "r'\\('", 'FORWARD_AXIS_NAME', "r'@'", 'REVERSE_AXIS_NAME', "r'\\.\\.'", "r'\\$'", "r'\\.'", 'FUNCNAME', 'NUMBER', 'DQUOTE', 'SQUOTE', "r'processing-instruction\\s*\\('", "r'comment\\s*\\('", "r'text\\s*\\('", "r'node\\s*\\('", "r'\\*'", 'NCNAME', context=_context)
        if _token == "r'\\-'":
            self._scan("r'\\-'", context=_context)
            ValueExpr = self.ValueExpr(_context)
            return X.NegationExpr(ValueExpr)
        else:
            ValueExpr = self.ValueExpr(_context)
            return ValueExpr

    def ValueExpr(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'ValueExpr', [])
        PathExpr = self.PathExpr(_context)
        return PathExpr

    def PathExpr(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'PathExpr', [])
        _token = self._peek("r'\\/'", "r'\\/\\/'", "r'\\('", 'FORWARD_AXIS_NAME', "r'@'", 'REVERSE_AXIS_NAME', "r'\\.\\.'", "r'\\$'", "r'\\.'", 'FUNCNAME', 'NUMBER', 'DQUOTE', 'SQUOTE', "r'processing-instruction\\s*\\('", "r'comment\\s*\\('", "r'text\\s*\\('", "r'node\\s*\\('", "r'\\*'", 'NCNAME', context=_context)
        if _token == "r'\\/'":
            self._scan("r'\\/'", context=_context)
            path = None
            if self._peek("r'\\('", 'FORWARD_AXIS_NAME', "r'@'", 'REVERSE_AXIS_NAME', "r'\\.\\.'", "r'\\$'", "r'\\.'", 'FUNCNAME', 'NUMBER', 'DQUOTE', 'SQUOTE', "r'processing-instruction\\s*\\('", "r'comment\\s*\\('", "r'text\\s*\\('", "r'node\\s*\\('", "r'\\*'", 'NCNAME', "'\\|'", 'MUL_COMP', 'ADD_COMP', 'REL_COMP', 'EQ_COMP', "r'and'", "r'or'", 'END', "r'\\]'", "r'\\)'", "r'\\,'", context=_context) not in ["'\\|'", 'MUL_COMP', 'ADD_COMP', 'REL_COMP', 'EQ_COMP', "r'and'", "r'or'", 'END', "r'\\]'", "r'\\)'", "r'\\,'"]:
                RelativePathExpr = self.RelativePathExpr(_context)
                path = RelativePathExpr
            return X.AbsolutePathExpr(path)
        elif _token == "r'\\/\\/'":
            self._scan("r'\\/\\/'", context=_context)
            RelativePathExpr = self.RelativePathExpr(_context)
            step = X.AxisStep('descendant-or-self')
            RelativePathExpr.steps.insert(0, step)
            return X.AbsolutePathExpr(RelativePathExpr)
        else:
            RelativePathExpr = self.RelativePathExpr(_context)
            return RelativePathExpr

    def RelativePathExpr(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'RelativePathExpr', [])
        StepExpr = self.StepExpr(_context)
        steps = [StepExpr]
        while self._peek("r'\\/'", "r'\\/\\/'", "'\\|'", 'MUL_COMP', 'ADD_COMP', 'REL_COMP', 'EQ_COMP', "r'and'", "r'or'", 'END', "r'\\]'", "r'\\)'", "r'\\,'", context=_context) in ["r'\\/'", "r'\\/\\/'"]:
            _token = self._peek("r'\\/'", "r'\\/\\/'", context=_context)
            if _token == "r'\\/'":
                self._scan("r'\\/'", context=_context)
            else: # == "r'\\/\\/'"
                self._scan("r'\\/\\/'", context=_context)
                steps.append(X.AxisStep('descendant-or-self'))
            StepExpr = self.StepExpr(_context)
            steps.append(StepExpr)
        return X.PathExpr(steps)

    def StepExpr(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'StepExpr', [])
        _token = self._peek("r'\\('", 'FORWARD_AXIS_NAME', "r'@'", 'REVERSE_AXIS_NAME', "r'\\.\\.'", "r'\\$'", "r'\\.'", 'FUNCNAME', 'NUMBER', 'DQUOTE', 'SQUOTE', "r'processing-instruction\\s*\\('", "r'comment\\s*\\('", "r'text\\s*\\('", "r'node\\s*\\('", "r'\\*'", 'NCNAME', context=_context)
        if _token not in ["r'\\('", "r'\\$'", "r'\\.'", 'FUNCNAME', 'NUMBER', 'DQUOTE', 'SQUOTE']:
            AxisStep = self.AxisStep(_context)
            return AxisStep
        else:
            FilterExpr = self.FilterExpr(_context)
            return FilterExpr

    def AxisStep(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'AxisStep', [])
        _token = self._peek('FORWARD_AXIS_NAME', "r'@'", 'REVERSE_AXIS_NAME', "r'\\.\\.'", "r'processing-instruction\\s*\\('", "r'comment\\s*\\('", "r'text\\s*\\('", "r'node\\s*\\('", "r'\\*'", 'NCNAME', context=_context)
        if _token not in ['REVERSE_AXIS_NAME', "r'\\.\\.'"]:
            ForwardStep = self.ForwardStep(_context)
            step = ForwardStep
        else: # in ['REVERSE_AXIS_NAME', "r'\\.\\.'"]
            ReverseStep = self.ReverseStep(_context)
            step = ReverseStep
        expr = X.AxisStep(*step)
        if self._peek("r'\\['", "r'\\/'", "r'\\/\\/'", "'\\|'", 'MUL_COMP', 'ADD_COMP', 'REL_COMP', 'EQ_COMP', "r'and'", "r'or'", 'END', "r'\\]'", "r'\\)'", "r'\\,'", context=_context) == "r'\\['":
            PredicateList = self.PredicateList(_context)
            expr = X.PredicateList(expr, PredicateList, step[0])
        return expr

    def ForwardStep(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'ForwardStep', [])
        _token = self._peek('FORWARD_AXIS_NAME', "r'@'", "r'processing-instruction\\s*\\('", "r'comment\\s*\\('", "r'text\\s*\\('", "r'node\\s*\\('", "r'\\*'", 'NCNAME', context=_context)
        if _token == 'FORWARD_AXIS_NAME':
            ForwardAxis = self.ForwardAxis(_context)
            NodeTest = self.NodeTest(_context)
            return [ForwardAxis, NodeTest]
        else:
            AbbrevForwardStep = self.AbbrevForwardStep(_context)
            return AbbrevForwardStep

    def ForwardAxis(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'ForwardAxis', [])
        FORWARD_AXIS_NAME = self._scan('FORWARD_AXIS_NAME', context=_context)
        self._scan("r'::'", context=_context)
        return FORWARD_AXIS_NAME

    def AbbrevForwardStep(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'AbbrevForwardStep', [])
        axis = 'child'
        if self._peek("r'@'", "r'processing-instruction\\s*\\('", "r'comment\\s*\\('", "r'text\\s*\\('", "r'node\\s*\\('", "r'\\*'", 'NCNAME', context=_context) == "r'@'":
            self._scan("r'@'", context=_context)
            axis = 'attribute'
        NodeTest = self.NodeTest(_context)
        return [axis, NodeTest]

    def ReverseStep(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'ReverseStep', [])
        _token = self._peek('REVERSE_AXIS_NAME', "r'\\.\\.'", context=_context)
        if _token == 'REVERSE_AXIS_NAME':
            ReverseAxis = self.ReverseAxis(_context)
            NodeTest = self.NodeTest(_context)
            return [ReverseAxis, NodeTest]
        else: # == "r'\\.\\.'"
            AbbrevReverseStep = self.AbbrevReverseStep(_context)
            return AbbrevReverseStep

    def ReverseAxis(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'ReverseAxis', [])
        REVERSE_AXIS_NAME = self._scan('REVERSE_AXIS_NAME', context=_context)
        self._scan("r'::'", context=_context)
        return REVERSE_AXIS_NAME

    def AbbrevReverseStep(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'AbbrevReverseStep', [])
        self._scan("r'\\.\\.'", context=_context)
        return ['parent', None]

    def NodeTest(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'NodeTest', [])
        _token = self._peek("r'processing-instruction\\s*\\('", "r'comment\\s*\\('", "r'text\\s*\\('", "r'node\\s*\\('", "r'\\*'", 'NCNAME', context=_context)
        if _token not in ["r'\\*'", 'NCNAME']:
            KindTest = self.KindTest(_context)
            return KindTest
        else: # in ["r'\\*'", 'NCNAME']
            NameTest = self.NameTest(_context)
            return NameTest

    def NameTest(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'NameTest', [])
        prefix = None
        WildcardOrNCName = self.WildcardOrNCName(_context)
        localpart = WildcardOrNCName
        if self._peek("r':'", "r'\\['", "r'\\/'", "r'\\/\\/'", "'\\|'", 'MUL_COMP', 'ADD_COMP', 'REL_COMP', 'EQ_COMP', "r'and'", "r'or'", 'END', "r'\\]'", "r'\\)'", "r'\\,'", context=_context) == "r':'":
            self._scan("r':'", context=_context)
            WildcardOrNCName = self.WildcardOrNCName(_context)
            prefix = localpart
            localpart = WildcardOrNCName
        return X.NameTest(prefix, localpart)

    def WildcardOrNCName(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'WildcardOrNCName', [])
        _token = self._peek("r'\\*'", 'NCNAME', context=_context)
        if _token == "r'\\*'":
            self._scan("r'\\*'", context=_context)
            return '*'
        else: # == 'NCNAME'
            NCNAME = self._scan('NCNAME', context=_context)
            return NCNAME

    def FilterExpr(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'FilterExpr', [])
        PrimaryExpr = self.PrimaryExpr(_context)
        if self._peek("r'\\['", "r'\\/'", "r'\\/\\/'", "'\\|'", 'MUL_COMP', 'ADD_COMP', 'REL_COMP', 'EQ_COMP', "r'and'", "r'or'", 'END', "r'\\]'", "r'\\)'", "r'\\,'", context=_context) == "r'\\['":
            PredicateList = self.PredicateList(_context)
            PrimaryExpr = X.PredicateList(PrimaryExpr,PredicateList)
        return PrimaryExpr

    def PredicateList(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'PredicateList', [])
        Predicate = self.Predicate(_context)
        predicates = [Predicate]
        while self._peek("r'\\['", "r'\\/'", "r'\\/\\/'", "'\\|'", 'MUL_COMP', 'ADD_COMP', 'REL_COMP', 'EQ_COMP', "r'and'", "r'or'", 'END', "r'\\]'", "r'\\)'", "r'\\,'", context=_context) == "r'\\['":
            Predicate = self.Predicate(_context)
            predicates.append(Predicate)
        return predicates

    def Predicate(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'Predicate', [])
        self._scan("r'\\['", context=_context)
        Expr = self.Expr(_context)
        self._scan("r'\\]'", context=_context)
        return Expr

    def PrimaryExpr(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'PrimaryExpr', [])
        _token = self._peek("r'\\('", "r'\\$'", "r'\\.'", 'FUNCNAME', 'NUMBER', 'DQUOTE', 'SQUOTE', context=_context)
        if _token not in ["r'\\('", "r'\\$'", "r'\\.'", 'FUNCNAME']:
            Literal = self.Literal(_context)
            return X.LiteralExpr(Literal)
        elif _token == "r'\\$'":
            VariableReference = self.VariableReference(_context)
            return VariableReference
        elif _token == "r'\\('":
            self._scan("r'\\('", context=_context)
            Expr = self.Expr(_context)
            self._scan("r'\\)'", context=_context)
            return Expr
        elif _token == "r'\\.'":
            ContextItemExpr = self.ContextItemExpr(_context)
            return ContextItemExpr
        else: # == 'FUNCNAME'
            FunctionCall = self.FunctionCall(_context)
            return FunctionCall

    def VariableReference(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'VariableReference', [])
        self._scan("r'\\$'", context=_context)
        QName = self.QName(_context)
        return X.VariableReference(*QName)

    def ContextItemExpr(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'ContextItemExpr', [])
        self._scan("r'\\.'", context=_context)
        return X.AxisStep('self')

    def FunctionCall(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'FunctionCall', [])
        FUNCNAME = self._scan('FUNCNAME', context=_context)
        self._scan("r'\\('", context=_context)
        args = []
        if self._peek("r'\\)'", "r'\\,'", "r'\\-'", "r'\\/'", "r'\\/\\/'", "r'\\('", 'FORWARD_AXIS_NAME', "r'@'", 'REVERSE_AXIS_NAME', "r'\\.\\.'", "r'\\$'", "r'\\.'", 'FUNCNAME', 'NUMBER', 'DQUOTE', 'SQUOTE', "r'processing-instruction\\s*\\('", "r'comment\\s*\\('", "r'text\\s*\\('", "r'node\\s*\\('", "r'\\*'", 'NCNAME', context=_context) not in ["r'\\)'", "r'\\,'"]:
            Expr = self.Expr(_context)
            args.append(Expr)
            while self._peek("r'\\,'", "r'\\)'", context=_context) == "r'\\,'":
                self._scan("r'\\,'", context=_context)
                Expr = self.Expr(_context)
                args.append(Expr)
        self._scan("r'\\)'", context=_context)
        return X.Function(FUNCNAME, args)

    def KindTest(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'KindTest', [])
        _token = self._peek("r'processing-instruction\\s*\\('", "r'comment\\s*\\('", "r'text\\s*\\('", "r'node\\s*\\('", context=_context)
        if _token == "r'processing-instruction\\s*\\('":
            PITest = self.PITest(_context)
            return PITest
        elif _token == "r'comment\\s*\\('":
            CommentTest = self.CommentTest(_context)
            return CommentTest
        elif _token == "r'text\\s*\\('":
            TextTest = self.TextTest(_context)
            return TextTest
        else: # == "r'node\\s*\\('"
            AnyKindTest = self.AnyKindTest(_context)
            return AnyKindTest

    def PITest(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'PITest', [])
        self._scan("r'processing-instruction\\s*\\('", context=_context)
        name = None
        if self._peek('NCNAME', "r'\\)'", 'DQUOTE', 'SQUOTE', context=_context) != "r'\\)'":
            _token = self._peek('NCNAME', 'DQUOTE', 'SQUOTE', context=_context)
            if _token == 'NCNAME':
                NCNAME = self._scan('NCNAME', context=_context)
                name = NCNAME
            else: # in ['DQUOTE', 'SQUOTE']
                StringLiteral = self.StringLiteral(_context)
                name = StringLiteral
        self._scan("r'\\)'", context=_context)
        return X.PITest(name)

    def CommentTest(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'CommentTest', [])
        self._scan("r'comment\\s*\\('", context=_context)
        self._scan("r'\\)'", context=_context)
        return X.CommentTest()

    def TextTest(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'TextTest', [])
        self._scan("r'text\\s*\\('", context=_context)
        self._scan("r'\\)'", context=_context)
        return X.TextTest()

    def AnyKindTest(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'AnyKindTest', [])
        self._scan("r'node\\s*\\('", context=_context)
        self._scan("r'\\)'", context=_context)
        return X.AnyKindTest()

    def Literal(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'Literal', [])
        _token = self._peek('NUMBER', 'DQUOTE', 'SQUOTE', context=_context)
        if _token == 'NUMBER':
            NumericLiteral = self.NumericLiteral(_context)
            return NumericLiteral
        else: # in ['DQUOTE', 'SQUOTE']
            StringLiteral = self.StringLiteral(_context)
            return StringLiteral

    def NumericLiteral(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'NumericLiteral', [])
        NUMBER = self._scan('NUMBER', context=_context)
        return float(NUMBER)

    def StringLiteral(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'StringLiteral', [])
        _token = self._peek('DQUOTE', 'SQUOTE', context=_context)
        if _token == 'DQUOTE':
            DQUOTE = self._scan('DQUOTE', context=_context)
            return DQUOTE[1:-1]
        else: # == 'SQUOTE'
            SQUOTE = self._scan('SQUOTE', context=_context)
            return SQUOTE[1:-1]

    def QName(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'QName', [])
        NCNAME = self._scan('NCNAME', context=_context)
        name = NCNAME
        if self._peek("r'\\:'", "r'\\['", "r'\\/'", "r'\\/\\/'", "'\\|'", 'MUL_COMP', 'ADD_COMP', 'REL_COMP', 'EQ_COMP', "r'and'", "r'or'", 'END', "r'\\]'", "r'\\)'", "r'\\,'", context=_context) == "r'\\:'":
            self._scan("r'\\:'", context=_context)
            NCNAME = self._scan('NCNAME', context=_context)
            return (name, NCNAME)
        return (None, name)


def parse(rule, text):
    P = XPath(XPathScanner(text))
    return runtime.wrap_error_reporter(P, rule)

if __name__ == '__main__':
    from sys import argv, stdin
    if len(argv) >= 2:
        if len(argv) >= 3:
            f = open(argv[2],'r')
        else:
            f = stdin
        print(parse(argv[1], f.read()))
    else: print ('Args:  <rule> [<filename>]', file=sys.stderr)
# End -- grammar generated by Yapps
